import ifcopenshell
import os

# Chemin du fichier IFC
IFC_FILE_PATH = "ifc_files/Biment_B.ifc"  # Ajuste selon ton fichier

def get_storeys(ifc_file):
    """ R√©cup√®re les √©tages et leurs √©l√©vations. """
    storeys = []
    for storey in ifc_file.by_type("IfcBuildingStorey"):
        elevation = storey.Elevation if storey.Elevation is not None else 0
        storeys.append((storey, elevation))
    storeys.sort(key=lambda x: x[1])  # Trier par √©l√©vation croissante
    return storeys

def get_object_z_and_storey(element):
    """ R√©cup√®re la hauteur Z d'un objet et l'√©tage auquel il est rattach√©. """
    obj_z = None
    obj_storey = None

    if element.ObjectPlacement:
        try:
            placement = element.ObjectPlacement.RelativePlacement
            if placement and hasattr(placement, "Location"):
                coords = placement.Location.Coordinates
                obj_z = coords[2] if len(coords) >= 3 else None

            # V√©rifier si l‚Äôobjet a un √©tage assign√© dans sa hi√©rarchie IFC
            if hasattr(element, "ContainedInStructure"):
                for relation in element.ContainedInStructure:
                    if relation.is_a("IfcRelContainedInSpatialStructure"):
                        parent = relation.RelatingStructure
                        if parent.is_a("IfcBuildingStorey"):
                            obj_storey = parent.Name
        except AttributeError:
            pass

    return obj_z, obj_storey

def check_objects(ifc_file):
    """ V√©rifie si des objets sont mal associ√©s aux √©tages. """
    storeys = get_storeys(ifc_file)
    
    # D√©terminer les bornes Z de chaque √©tage
    storey_bounds = []
    for i, (storey, z) in enumerate(storeys):
        z_top = storeys[i+1][1] if i+1 < len(storeys) else z + 3  # Estimation si dernier √©tage
        storey_bounds.append((storey, z, z_top))

    incorrect_objects = []
    no_position_objects = []

    for element in ifc_file.by_type("IfcProduct"):  # Tous les objets ayant un placement
        obj_z, obj_storey = get_object_z_and_storey(element)
        
        if obj_z is not None:
            found = False
            for storey, z_min, z_max in storey_bounds:
                if z_min <= obj_z < z_max:
                    found = True
                    break
            if not found:
                incorrect_objects.append((element, obj_z, obj_storey))
        else:
            no_position_objects.append(element)

    return incorrect_objects, no_position_objects, storey_bounds  # Retourne aussi les √©tages pour analyse

def main():
    if not os.path.exists(IFC_FILE_PATH):
        print(f"Erreur : Fichier IFC non trouv√© -> {IFC_FILE_PATH}")
        return

    print(f"üîç Analyse du fichier IFC : {IFC_FILE_PATH}")
    ifc_file = ifcopenshell.open(IFC_FILE_PATH)
    incorrect_objs, no_position_objs, storey_bounds = check_objects(ifc_file)

    output_path = "outputs/resultats.txt"
    
    # ‚úÖ Cr√©er le dossier 'outputs' s'il n'existe pas
    output_dir = os.path.dirname(output_path)
    os.makedirs(output_dir, exist_ok=True)

    # ‚úÖ √âcriture du fichier apr√®s s'√™tre assur√© que le dossier existe
    with open(output_path, "w") as f:
        for obj, z, current_storey in incorrect_objs:
            # Trouver l'√©tage le plus proche bas√© sur la distance aux bornes de chaque √©tage
            closest_storey = min(
                storey_bounds,
                key=lambda s: min(abs(z - s[1]), abs(z - s[2]))
            )

            storey_obj, storey_z_min, storey_z_max = closest_storey
            storey_name = storey_obj.Name

            # D√©terminer si l'objet est plus proche du bas ou du haut de l'√©tage trouv√©
            if abs(z - storey_z_min) < abs(z - storey_z_max):
                position_suggestion = "Il semble √™tre situ√© l√©g√®rement sous l‚Äô√©tage."
            else:
                position_suggestion = "Il semble √™tre plac√© juste au-dessus de l‚Äô√©tage."

            # Affichage de l‚Äô√©tage actuel ou indication qu‚Äôil n‚Äôa pas d‚Äô√©tage assign√©
            current_storey_text = f"et est li√© √† l‚Äô√©tage '{current_storey}'" if current_storey else "et n'est li√© √† aucun √©tage"

            # Message d√©taill√©
            result = (
                f"‚ö†Ô∏è L‚Äôobjet '{obj.Name}' (ID: {obj.GlobalId}) est actuellement √† Z={z} m {current_storey_text}.\n"
                f"üìç Il devrait √™tre rattach√© √† l‚Äô√©tage '{storey_name}' "
                f"qui s'√©tend de {storey_z_min} m √† {storey_z_max} m.\n"
                f"üîé {position_suggestion} V√©rifiez son placement ou son association IFC.\n\n"
            )
            
            print(result, end="")
            f.write(result)

        if no_position_objs:
            f.write("\nüö® Objets sans position d√©tect√©s :\n")
            print("\nüö® Objets sans position d√©tect√©s :")
            for obj in no_position_objs:
                msg = f"‚ùå L‚Äôobjet '{obj.Name}' (ID: {obj.GlobalId}) n‚Äôa pas de position d√©finie.\n"
                print(msg, end="")
                f.write(msg)

    print(f"\n‚úÖ Analyse termin√©e. R√©sultats enregistr√©s dans {output_path}")

if __name__ == "__main__":
    main()
