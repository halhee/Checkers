import ifcopenshell
import ifcopenshell.geom
import json


def calculate_bounding_box(vertices):
    """
    Calcule une bounding box à partir des vertices.
    """
    x_coords = vertices[0::3]
    y_coords = vertices[1::3]
    z_coords = vertices[2::3]
    return (min(x_coords), min(y_coords), min(z_coords),
            max(x_coords), max(y_coords), max(z_coords))


def extract_objects_with_bounding_boxes(file_path, settings):
    """
    Extrait les objets pertinents avec leurs bounding boxes.
    """
    ifc_file = ifcopenshell.open(file_path)
    objects = []

    # Types MEP et architecturaux à inclure
    relevant_types = [
        # MEP
        "IfcPipeSegment", "IfcDuctSegment", "IfcCableSegment",
        "IfcFlowSegment", "IfcFlowFitting", "IfcFlowTerminal",
        # Architecturaux
        "IfcWall", "IfcSlab", "IfcBeam", "IfcColumn", "IfcRoof"
    ]

    for product in ifc_file.by_type("IfcProduct"):
        if product.is_a() not in relevant_types:
            # Ignorer les objets non pertinents
            continue

        if not product.Representation:
            print(f"Objet ignoré (pas de représentation) : {product.GlobalId} ({product.is_a()})")
            continue

        try:
            shape = ifcopenshell.geom.create_shape(settings, product)
            geometry = shape.geometry

            # Vérifier si la bounding box est disponible
            if hasattr(geometry, "bounding_box"):
                bbox = geometry.bounding_box
            else:
                # Calculer la bounding box à partir des vertices
                bbox = calculate_bounding_box(geometry.verts)

            objects.append({
                "global_id": product.GlobalId,
                "name": product.Name,
                "type": product.is_a(),
                "bbox": bbox,
            })

        except Exception as e:
            print(f"Erreur lors de l'extraction de la géométrie pour {product.GlobalId}: {e}")

    return objects


def check_bbox_collision(bbox1, bbox2):
    """
    Vérifie si deux bounding boxes se chevauchent.
    """
    return (
        bbox1[0] < bbox2[3] and bbox1[3] > bbox2[0] and  # Chevauchement sur X
        bbox1[1] < bbox2[4] and bbox1[4] > bbox2[1] and  # Chevauchement sur Y
        bbox1[2] < bbox2[5] and bbox1[5] > bbox2[2]      # Chevauchement sur Z
    )


def detect_collisions_by_bounding_boxes(objects1, objects2):
    """
    Détecte les collisions en comparant les bounding boxes des objets.
    """
    collisions = []

    for obj1 in objects1:
        for obj2 in objects2:
            if check_bbox_collision(obj1["bbox"], obj2["bbox"]):
                collisions.append((obj1, obj2))

    return collisions


def write_collisions_to_file(collisions, output_file):
    """
    Écrit les collisions dans un fichier JSON.
    """
    results = []
    for obj1, obj2 in collisions:
        results.append({
            "object_1": {
                "global_id": obj1["global_id"],
                "type": obj1["type"],
                "name": obj1["name"]
            },
            "object_2": {
                "global_id": obj2["global_id"],
                "type": obj2["type"],
                "name": obj2["name"]
            }
        })

    with open(output_file, "w", encoding="utf-8") as f:
        json.dump(results, f, indent=4, ensure_ascii=False)
    print(f"Collisions sauvegardées dans : {output_file}")


def main(file1, file2, output_file):
    """
    Fonction principale pour extraire les objets et détecter les collisions.
    """
    settings = ifcopenshell.geom.settings()
    settings.set(settings.USE_WORLD_COORDS, True)

    print("Extraction des objets MEP et architecturaux...")
    objects1 = extract_objects_with_bounding_boxes(file1, settings)
    objects2 = extract_objects_with_bounding_boxes(file2, settings)

    print(f"Nombre d'objets pertinents extraits dans le fichier 1 : {len(objects1)}")
    print(f"Nombre d'objets pertinents extraits dans le fichier 2 : {len(objects2)}")

    # Détection des collisions
    print("Détection des collisions entre les objets MEP et architecturaux...")
    collisions = detect_collisions_by_bounding_boxes(objects1, objects2)
    print(f"Nombre de collisions détectées : {len(collisions)}")

    # Sauvegarder les collisions dans un fichier
    write_collisions_to_file(collisions, output_file)


if __name__ == "__main__":
    FILE1 = "/Users/bouznir/Desktop/checkers_clash/maquettes/Adil SAOUSSEN - Maison contemporaine - MN MEP.ifc"
    FILE2 = "/Users/bouznir/Desktop/checkers_clash/maquettes/Adil SAOUSSEN - Maison contemporaine - MN Archi.ifc"
    OUTPUT_FILE = "/Users/bouznir/Desktop/checkers_clash/output_collisions.json"

    main(FILE1, FILE2, OUTPUT_FILE)
