import ifcopenshell
import ifcopenshell.geom
import json
import openai


def calculate_bounding_box(vertices):
    x_coords = vertices[0::3]
    y_coords = vertices[1::3]
    z_coords = vertices[2::3]
    return (min(x_coords), min(y_coords), min(z_coords),
            max(x_coords), max(y_coords), max(z_coords))


def extract_objects_with_bounding_boxes(file_path, settings):
    ifc_file = ifcopenshell.open(file_path)
    objects = []

    relevant_types = [
        # MEP
        "IfcPipeSegment", "IfcDuctSegment", "IfcCableSegment",
        "IfcFlowSegment", "IfcFlowFitting", "IfcFlowTerminal",
        # Architecturaux
        "IfcWall", "IfcSlab", "IfcBeam", "IfcColumn", "IfcRoof"
    ]

    for product in ifc_file.by_type("IfcProduct"):
        if product.is_a() not in relevant_types:
            continue

        if not product.Representation:
            print(f"Objet ignoré (pas de représentation) : {product.GlobalId} ({product.is_a()})")
            continue

        try:
            shape = ifcopenshell.geom.create_shape(settings, product)
            geometry = shape.geometry

            if hasattr(geometry, "bounding_box"):
                bbox = geometry.bounding_box
            else:
                bbox = calculate_bounding_box(geometry.verts)

            objects.append({
                "global_id": product.GlobalId,
                "name": product.Name,
                "type": product.is_a(),
                "bbox": bbox,
            })

        except Exception as e:
            print(f"Erreur lors de l'extraction de la géométrie pour {product.GlobalId}: {e}")

    return objects


def check_bbox_collision(bbox1, bbox2):
    return (
        bbox1[0] < bbox2[3] and bbox1[3] > bbox2[0] and
        bbox1[1] < bbox2[4] and bbox1[4] > bbox2[1] and
        bbox1[2] < bbox2[5] and bbox1[5] > bbox2[2]
    )


def detect_collisions_by_bounding_boxes(objects1, objects2):
    collisions = []

    for obj1 in objects1:
        for obj2 in objects2:
            if check_bbox_collision(obj1["bbox"], obj2["bbox"]):
                collisions.append((obj1, obj2))

    return collisions


def generate_comment_for_clash(obj1, obj2, api_key):
    """
    Utilise l'API OpenAI pour générer un commentaire expliquant la collision.
    """
    prompt = (
        f"Voici une collision détectée dans un modèle BIM :\n"
        f"- Objet 1 : {obj1['type']} (Nom : {obj1['name']}, ID : {obj1['global_id']})\n"
        f"- Objet 2 : {obj2['type']} (Nom : {obj2['name']}, ID : {obj2['global_id']})\n"
        f"Tu es un expert en BIM, en synthèse technique et en gestion de projet de construction. À partir des données fournies, donne un commentaire sur cette collision et suggère une solution pour résoudre ce problème.A la fin de chaque commentaire, tu mettras une note de criticité de sur 5. 1 étant peu grave et 5 étant critique."
    )

    try:
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}]
        )
        return response["choices"][0]["message"]["content"].strip()
    except Exception as e:
        print(f"Erreur lors de l'appel à l'API OpenAI : {e}")
        return "Impossible de générer un commentaire pour ce clash."


def write_collisions_with_comments_to_file(collisions, output_file, api_key):
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("[\n")  # Ouvre la liste JSON
        for i, (obj1, obj2) in enumerate(collisions):
            comment = generate_comment_for_clash(obj1, obj2, api_key)
            result = {
                "object_1": {
                    "global_id": obj1["global_id"],
                    "type": obj1["type"],
                    "name": obj1["name"]
                },
                "object_2": {
                    "global_id": obj2["global_id"],
                    "type": obj2["type"],
                    "name": obj2["name"]
                },
                "comment": comment
            }
            f.write(json.dumps(result, indent=4, ensure_ascii=False))
            if i < len(collisions) - 1:
                f.write(",\n")  # Ajoute une virgule sauf pour le dernier
        f.write("\n]\n")  # Ferme la liste JSON
    print(f"Collisions avec commentaires sauvegardées dans : {output_file}")


def main(file1, file2, output_file):
    api_key = "API_key"  # Remplace par ta clé API OpenAI
    openai.api_key = api_key

    settings = ifcopenshell.geom.settings()
    settings.set(settings.USE_WORLD_COORDS, True)

    print("Extraction des objets MEP et architecturaux...")
    objects1 = extract_objects_with_bounding_boxes(file1, settings)
    objects2 = extract_objects_with_bounding_boxes(file2, settings)

    print(f"Nombre d'objets pertinents extraits dans le fichier 1 : {len(objects1)}")
    print(f"Nombre d'objets pertinents extraits dans le fichier 2 : {len(objects2)}")

    print("Détection des collisions entre les objets MEP et architecturaux...")
    collisions = detect_collisions_by_bounding_boxes(objects1, objects2)
    print(f"Nombre de collisions détectées : {len(collisions)}")

    print("Génération des commentaires pour chaque collision...")
    write_collisions_with_comments_to_file(collisions, output_file, api_key)


if __name__ == "__main__":
    FILE1 = "/Users/bouznir/Desktop/checkers_clash/maquettes/Adil SAOUSSEN - Maison contemporaine - MN MEP.ifc"
    FILE2 = "/Users/bouznir/Desktop/checkers_clash/maquettes/Adil SAOUSSEN - Maison contemporaine - MN Archi.ifc"
    OUTPUT_FILE = "/Users/bouznir/Desktop/checkers_clash/output_collisions.json"

    main(FILE1, FILE2, OUTPUT_FILE)

